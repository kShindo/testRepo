# 項目63 文字列結合のパフォーマンスに用心する
　  
「＋」（文字列の結合演算子）は、文字列結合の便利な演算子  
　  
これは
- １行の出力生成
- 小さな固定サイズオブジェクトの文字列構築
　  
には向いてるが、それ以上は向いてない。
　  
　  
文字列結合演算子を繰り返し使うと、ｎ個の文字列の結合にはｎの二次の時間が必要。  
文字列が不変という不幸な結果：二つの文字列が結合される場合、両方の内容がコピーされる。  
　  
【 教訓 】  
	パフォーマンスが問題になる場合、数個より多くの文字列結合には、  
	文字列結合演算子でなく、StringBuilderのappendメソッドを使うべし！  
	それか、文字配列や、結合でなく文字列を１つずつ処理すべし！  
　  
　  
　  
# 項目64 インターフェースでオブジェクトを参照する
　  
項目51：パラメータ型にはクラスでなくインタフェースを使うべき  
（∵オブジェクトを、より一般的に参照するため）  
　  
**適切なインタフェースが存在**する場合、上記に加え  
- 戻り値
- 変数
- フィールド  
　  
についても、**インタフェースで宣言**せよ。
　  
インタフェースで宣言すれば、**コンストラクタを変えるだけで実装が切り替え**られる。
×	LinkedHashSet<Son> sonSet =	new LinedHashSet<>();
								new HashSet<>()には置き換えられない。
○	Set<Son> sonSet =	new LinkedHashSet<>();
						new HashSet<>()にも置き換えられる。
つまり、**プログラムが柔軟**になる。
　  
【 但し、**注意点**あり 】
元の実装が（インタフェースの一般契約で要求されなていない何らかの）特別な機能を提供し、  
コードが、その機能に依存するなら、新たな実装が同じ機能を提供することが重要  
　  
例  
コードが順序付けポリシーに依存するのに、LinkedHashSetをHashSetで代用すると結果が変わる
　  
　  
【実装を切り替えたくなる理由】
- 優れたパフォーマンスを提供
- より望ましい機能を提供  
　  
　  
例1  
HashMapを含むフィールドをEnumMapへ変えれば  
- パフォーマンスが向上
- イテレーションの順序はキーの自然な順序と一致  
但し、これが使えるのはキーの型が enum 型の場合だけ  
　  
例2  
HashMapをLinkedHashMapに変えれば
- 同等性能で予想可能なイテレーション順序が提供される  
　  
　  
【 **注意** 】
宣言と実装の型を合わせても、コンパイルが通る保証は無い。　  
- クライアントコードが新たな型で存在せず、元の型だけにある  
- クライアントコードが元の実装型を要求するメソッドへのインスタンスを渡している
　  
　  
これらに反し『適切なインタフェースが存在しない』場合　  
クラスの型そのものでオブジェクトを参照することは適切　  
　  
適切なI/Fが存在しない例1  
一般にStringやBigInteger等の値クラスはfinalで、複数の実装を持ったり、  
対応するインタフェースを持つのは稀（クラスがfinalじゃ継承が抑制されてる）  
　  
適切なI/Fが存在しない例2  　  
オブジェクトが『基本となる型がインタフェースでなくクラスであるフレームワーク』に属している場合　  
一般に抽象クラスである関連する基底クラスで参照するのが望ましい。　  
OutputStream等のjava.ioの多くのクラスがこれにあたる。　  
　  
適切なI/Fが存在しない例3  　  
インタフェースは実装しているが、そのインタフェースに無い追加のメソッドをクラスが提供してる場合  
Queueインタフェースで定義されてないcomparatorメソッドを持つPriorityQueueが該当　  
これはプログラムが、その追加メソッドに依存してる場合にのみ、そのインスタンスを参照するために使われるべき  
こういうケースは極めて稀であるべき　  
　  

【 **まとめ** 】  
以上３ケースは一部の例。オブジェクトをクラスで参照するのが適切な状況を単に伝えただけ。　  
オブジェクトが適切なインタフェースを持つか否かは明白であるべき。　  
持ってるのであれば、オブジェクト参照をインタフェースとすることで、プログラムは柔軟で洗練される。　  
インタフェースが無ければ、クラス階層中で必要な機能を提供する最も上位のクラスを利用すべし。　  
　  
　  
# 項目65　リフレクションよりもインタフェースを選ぶ　  
　  
コア・リフレクション機構である java.lang.reflect は、  
任意のクラスに対するプログラミングによるアクセスを提供している。　  
　  
これにより、オブジェクトのコンストラクタやメソッドやフィールドの参照や変更　  
だけでなく、メソッドの呼び出しやインスタンス生成も可能となる。　  
例えば、Method.invokeで任意のクラスの任意のオブジェクトに対し、メソッドが呼び出せる。　  
但し、これには代価が伴う　  
- 例外検査も含め、コンパイル時の型検査の恩恵を全て失う　  
　存在してないか、アクセス不能なメソッドなのでチェックできず、実行時に失敗　  
- リフレクションによるアクセスを行うコードは、ぎこちなく冗長　  
　書くのが面倒で、読むのも難しい　  
- パフォーマンスが悪くなる　  
　通常のメソッド呼び出しよりかなり遅い。　  
　  
これが必要となるアプリの例　  
- コード解析ツール　  
- 依存性注入フレームワーク　  
　  
ただ欠点が明らかなため、上記ケースでも使わなくなってきてるらしい。　  
必要かどうかが疑問なら、恐らく不要。　  
　  
利用が限定的であれば、コストを殆ど負うことなく利点を得られる。　  
コンパイル時に無いクラスでも、適切なインタフェースやスーパークラスを通すことでインスタンスにアクセス可能　  
　  
　  
サンプルPGは、サービスプロバイダフレームワーク（項目１）の実装に十分。　  
　  
サンプルPGで示される２つの短所　  
１、実行時に6個の異なる実例を発生させる可能性がある。　  
リフレクションを使ってなければ、これはコンパイルエラーになる。　  
　  
２、名前からクラスのインスタンスをリフレクションにより生成するために、25行もの長ったらしいコードが必要　  
コンストラクタであれば、１行で済む。　  
またJAVA7で導入された ReflectiveOperationException （様々なリフレクションの例外のスーパークラス）　  
をキャッチすれば、短く出来る。　  
　  
これらの短所は、オブジェクトのインスタンス生成部分に限定される。一旦インスタンス化されれば、　  
他のどのSetインスタンスとも区別できない。　  
　  
コンパイル時には未検査キャストの警告メッセージが出る。警告抑制は項目27参照　  
　  
利用は稀であるべきだが、実行時には存在しないかも知れない他のクラス、メソッド、フィールドに対する　  
クラスの依存性を管理するのも正当な使い方。他のパッケージの複数のバージョンに対し動作しなければ　  
ならないパッケージを書くなら有用。　  
最低（一般に、最も古いバージョン）の環境でコンパイルし、新たなクラスやメソッドにはリフレクションでアクセス。　  
同じ目的を達成するため、何らかのた代替手段を使うか、少ない機能で動作するように、適切に処理すべき。　  
　  
【 **まとめ** 】  
リフレクションは強力で必要な機構だが、多くの短所がある。　  
コンパイル時に存在しないクラスと一緒に動作しないとならないコードを書く場合であっても、　  
オブジェクトのインスタンス化のみに利用を限定し、コンパイル時に分かっているインタフェースや  　  
スーパークラスを使ってアクセスすべき。　  
　  
　  
