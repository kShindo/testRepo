# 75	詳細メッセージにエラー記録情報を含める
## 例外をキャッチしないと、スタックトレースが出る

### **エラー原因となる情報を極力多く出す** ことが重要  
内容には、例外の toString メソッド実行結果である **「例外の文字列表現」** を含むこと  
通常は、例外のクラス名と詳細メッセージで構成する  
分析のため、具体的には  
* 全パラメータ  
* フィールド値  

を詳細メッセージとして記録しておくべき  

例えばIndexOutOfBoundsExceptionであれば  
* 下限範囲  
* 上限範囲  
* 実際のインデックス値  

をメッセージに加える。
　  
### **注意：セキュリティに影響する情報の記録**  
以下の情報はメッセージに含むべきでない  
* パスワード
* 暗号鍵

### 長い説明は不要
スタックトレースは、ソースと一緒に分析することを意図している。  
例外の詳細メッセージと、ユーザレベルのガイダンスを混同してはならない。  
例外メッセージは、プログラマやサイト・リライアビリティ・エンジニアが対象  
↑　「読み易さ」より「情報の内容」の方が遥かに重要

適切なエラー記録情報
文字列の詳細メッセージの代わりに、情報を例外コンストラクタで要求
↑　必要な情報を含むよう自動的に生成できる
★サンプルソース：IndexOutOfBounds（lower, upper, idx）
こうした例は、強く推奨される。
例外のアクセッサー提供は適切。
チェック例外であれば、なおさら。
↑　エラー回復に役立つカモ
非チェック例外へのアクセスは稀でも、アクセッサー提供は望ましい

# 76	エラーアトミック性に努める
例外発生後も、オブジェクトは利用可能な状態が望ましい。  
例外からの回復が期待されるチェック例外であれば、特に必要。  
メソッドが失敗しても、オブジェクトは呼び出し前の状態であるべき。  
目的達成の方法は複数  
不変オブジェクトを設計する（最も簡単）  
操作を行う前にパラメータの妥当性を検査（可変Obj操作で最も一般的）  
失敗の可能性がある処理は、オブジェクト変更の前  
オブジェクトの一時的コピーに対し操作し、正常ならコピーを結果とする  
例：ソート前にリストを配列に出力（性能面でも有利）  
操作途中のエラーを捕らえ、操作開始前に状態を戻す「回復コード」  
一般的ではないが、主に永続的データ構造に使われる  
エラーアトミック性は望ましいが、必ずしも達成可能とは限らない  
２スレッドが同一Objを非同期に更新  
→　Objが不整合となる可能性  
一般に回復不能であれば、エラーアトミック性を保持する努力は不要  
エラーアトミック可能でも、望ましくない例  
コストや複雑さが著しく増すケース  
（たいていは、コストもかからず容易）  
## まとめ  
例外がメソッド仕様の一部であれば、Objはメソッド呼び出し前の状態にすべき  
それが出来なければ、Objが置かれる状態をドキュメントに明示すべき  
残念なことに、既存のAPIドキュメントは、理想通りでない  

# 77	例外を無視しない
明らかな助言に見えるが、繰り返すに十分なほど守られない  
例外スローの宣言は、設計者が何かを伝えようとしている  
無視すべきでない  
ソースサンプル：catchブロックを空にすることで、例外は容易に無視できる  
↑　例外の目的は達成されない  
例外の無視は、火災報知器の警報を切ってしまうのと同じ  
これを見たら、頭のかなの警報を鳴らせ！  
一報、例外の無視が適切な場合も  
FileInputStreamクローズ時、ファイル変更が無ければ回復も不要  
必要な情報の取得後であれば、処理中断すら不要  
但し、こうしたケースでも例外の記録は賢明  
頻繁に発生しているなど、問題を調査できる  
例外無視を選択したら  
理由を説明するコメントを catch ブロックに記述  
変数は「ignore」と命名  
これらの助言は、チェック例外と非チェック例外の両方に適用される  
予想可能な例外を無視すれば、エラーが有ってもPGは継続できる。  
その後に関係ないコードでエラーになるかも知れない。  
例外を適切に処理することで、失敗そのものを防げる  
チェックされない例外を、少なくとも外側に単に伝播させるだけでも、  
プログラムを速やかにエラーにさせ、そのエラーのデバッグに役立つ情報を残せる。  
