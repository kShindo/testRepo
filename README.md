# 75	詳細メッセージにエラー記録情報を含める
## 例外をキャッチしないと、スタックトレースが出る

### **エラー原因となる情報を極力多く出す** ことが重要  
内容には、例外の toString メソッド実行結果である **「例外の文字列表現」** を含むこと  
通常は、例外のクラス名と詳細メッセージで構成する  
分析のため、具体的には  
* 全パラメータ  
* フィールド値  

を詳細メッセージとして記録しておくべき  

例えばIndexOutOfBoundsExceptionであれば  
* 下限範囲  
* 上限範囲  
* 実際のインデックス値  

をメッセージに加える。

### **注意：セキュリティに影響する情報の記録**  
以下の情報はメッセージに含むべきでない  
* パスワード
* 暗号鍵

### 長い説明は不要
スタックトレースは、ソースと一緒に分析することを意図している。  
例外の詳細メッセージと、ユーザレベルのガイダンスを混同してはならない。  
例外メッセージは、プログラマやサイト・リライアビリティ・エンジニアが対象  
↑　「読み易さ」より「情報の内容」の方が遥かに重要  

適切なエラー記録情報  
文字列の詳細メッセージの代わりに、情報を例外コンストラクタで要求  
↑　必要な情報を含むよう自動的に生成できる  
★サンプルソース：IndexOutOfBounds（lower, upper, idx）  
```
/**
 * IndexOutOfBoundsExceptionを生成する
 *
 * @param lowerBound 最も小さな正当インデックス値
 * @param upperBound 最も大きな正当インデックス値に1を足した値
 * @param index      実際のインデックス値
 */
public IndexOutOfBoundsExcetion(int lowerBound, int upperBound, int index) {
    // エラーを記録する詳細メッセージを生成する
    super(String.format(
            "Lower bound: %d, Upper Bound: %d Index: %d",
            lowerBound, upperBound, index));

    // プログラミングによるアクセスのためエラー情報を保存する
    this.lowerBound = lowerBound;
    this.upperBound = upperBound;
    this.index = index;
}
```
　  
こうした例は、強く推奨される。  
例外のアクセッサー（getterによる値の取得メソッド）提供は適切。  
チェック例外であれば、なおさら。  
↑　エラー回復に役立つカモ  
非チェック例外へのアクセスは稀でも、アクセッサー提供は望ましい  

# 76	エラーアトミック性に努める
## メソッド失敗時も、オブジェクトは呼び出し前の状態であるべき  
例外発生後も、オブジェクトは利用可能な状態が望ましい。  
例外からの回復が期待されるチェック例外であれば、特に。  
　  
複数の目的達成方法  
### １、不変オブジェクトを設計する（低コスト、最も簡単な方法）  
### ２、操作を行う前にパラメータの妥当性を検査：項目４９（可変オブジェクト操作に最も一般的）  
```
public Object pop() {
    if (size == 0)
        throw new EmptyStackException();
    Object result = null; // 使われなくなった参照を取り除く
    resturn result;
}
```
### ２.5、失敗の可能性がある処理は、オブジェクト変更の前  
### ３、オブジェクトの一時的コピーに対し操作し、正常ならコピーを結果とする  
　例：ソート前にリストを配列に出力（性能面でも有利）  
### ４、操作途中のエラーを捕らえ、操作開始前に状態を戻す「回復コード」
　　(一般的ではない。主に永続的データ構造に使われる）  
## エラーアトミック性は望ましいが、必ずしも達成可能とは限らない  
２スレッドが同一オブジェクトを非同期に更新  
→　オブジェクトが不整合となる可能性  
## 一般に回復不能であれば、エラーアトミック性を保持する努力は不要  
エラーアトミック可能でも、望ましくない例  
コストや複雑さが著しく増すケース  
（たいていは、コストもかからず容易）  
## まとめ  
例外がメソッド仕様の一部であれば、オブジェクトはメソッド呼び出し前の状態にすべき  
それが出来なければ、オブジェクトが置かれる状態をドキュメントに明示すべき  
残念なことに、既存のAPIドキュメントは、理想通りでない  

# 77	例外を無視しない
## 明らかな助言に見えるが、繰り返すに十分なほど守られない  
例外スローの宣言は、設計者が何かを伝えようとしている  
無視すべきでない  
ソースサンプル：catchブロックを空にすることで、例外は容易に無視できる  
↑　例外の目的は達成されない  
## 例外の無視は、火災報知器の警報を切ってしまうのと同じ  
見たら、頭の中の警報を鳴らせ！  
## 一方で、例外の無視が適切なケース  
FileInputStreamクローズ時、ファイル変更が無ければ回復も不要  
既に必要な情報取得後であれば、処理中断すら不要  
但し、こうしたケースでも例外の記録は賢明  
∵　頻繁に発生しているなど、問題を調査できる  
## **もし例外無視を選択** したら  
* 理由を説明するコメントを catch ブロックに記述  
* 変数は「ignore」と命名  

これらの助言は、チェック例外と非チェック例外の両方に適用される  
予想可能な例外を無視すれば、エラーが有ってもPGは継続できる。  
（その後に関係ないコードでエラーになるかも知れないが）  

## 例外を適切に処理することで、失敗そのものを防げる  
チェックされない例外を、少なくとも外側に単に伝播させるだけでも、  
プログラムを速やかにエラーにさせ、そのエラーのデバッグに役立つ情報を残せる。  
